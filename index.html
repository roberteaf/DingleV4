<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fixed FPS with Joystick + Minimap</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; height: 100%;
    background: #000;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }
  #gameCanvas {
    position: absolute;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    display: block;
    background: #222;
    z-index: 0;
  }
  #minimap {
    position: fixed;
    bottom: 10px;
    right: 10px;
    width: 150px;
    height: 150px;
    border: 2px solid cyan;
    background: #000;
    z-index: 10;
  }
  #joystickBase {
    position: fixed;
    bottom: 10px;
    left: 10px;
    width: 120px;
    height: 120px;
    background: rgba(255,255,255,0.15);
    border-radius: 50%;
    touch-action: none;
    z-index: 10;
    border: 2px solid cyan;
  }
  #joystickKnob {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 60px;
    height: 60px;
    margin-left: -30px;
    margin-top: -30px;
    background: rgba(0, 255, 255, 0.7);
    border-radius: 50%;
    pointer-events: none;
  }
  #shootButton, #reloadButton {
    position: fixed;
    bottom: 10px;
    right: 10px;
    width: 100px;
    height: 50px;
    font-size: 18px;
    font-weight: bold;
    color: white;
    background: crimson;
    border-radius: 8px;
    border: none;
    z-index: 10;
    user-select: none;
  }
  #reloadButton {
    bottom: 70px;
    background: darkorange;
  }
  #health, #ammo, #reloadStatus {
    position: fixed;
    top: 10px;
    left: 10px;
    color: white;
    font-family: monospace;
    font-weight: bold;
    z-index: 20;
    user-select: none;
  }
  #ammo {
    top: 40px;
  }
  #reloadStatus {
    top: 70px;
    color: yellow;
  }
  #crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin-left: -10px;
    margin-top: -10px;
    pointer-events: none;
    z-index: 15;
  }
  #crosshair:before, #crosshair:after {
    content: '';
    position: absolute;
    background: cyan;
    border-radius: 2px;
  }
  #crosshair:before {
    top: 9px;
    left: 0;
    width: 20px;
    height: 2px;
  }
  #crosshair:after {
    top: 0;
    left: 9px;
    width: 2px;
    height: 20px;
  }
  #crosshair.hit:before, #crosshair.hit:after {
    background: red;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<canvas id="minimap"></canvas>

<div id="joystickBase">
  <div id="joystickKnob"></div>
</div>

<button id="shootButton">Shoot</button>
<button id="reloadButton">Reload</button>

<div id="health">Health: 100</div>
<div id="ammo">Ammo: 10</div>
<div id="reloadStatus"></div>

<div id="crosshair"></div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const minimap = document.getElementById('minimap');
  const mmCtx = minimap.getContext('2d');

  const joystickBase = document.getElementById('joystickBase');
  const joystickKnob = document.getElementById('joystickKnob');

  const shootButton = document.getElementById('shootButton');
  const reloadButton = document.getElementById('reloadButton');

  const healthDisplay = document.getElementById('health');
  const ammoDisplay = document.getElementById('ammo');
  const reloadStatus = document.getElementById('reloadStatus');
  const crosshair = document.getElementById('crosshair');

  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  minimap.width = 150;
  minimap.height = 150;

  // Player data
  const player = {
    x: 150,
    y: 150,
    radius: 15,
    angle: 0,
    moveX: 0,
    moveY: 0,
    speed: 150,
    health: 100,
    ammo: 10,
    ammoMax: 10,
    reloading: false,
    reloadTimer: 0,
  };

  // Map
  const mapWidth = 10;
  const mapHeight = 10;
  const tileSize = 64;

  // 1 = wall, 0 = empty
  const map = [
    [1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,1,1,0,0,1],
    [1,0,0,0,0,1,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,1,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1],
  ];

  // Normalize angle between 0 and 2PI
  function normalizeAngle(angle) {
    angle %= 2 * Math.PI;
    if (angle < 0) angle += 2 * Math.PI;
    return angle;
  }

  // Collision check with walls
  function isWalkable(x, y) {
    const mapX = Math.floor(x / tileSize);
    const mapY = Math.floor(y / tileSize);
    if (mapX < 0 || mapX >= mapWidth || mapY < 0 || mapY >= mapHeight) return false;
    return map[mapY][mapX] === 0;
  }

  // Update player position
  function updatePlayer(dt) {
    let moveSpeed = player.speed * dt;
    let moveX = player.moveX;
    let moveY = player.moveY;
    // Normalize move if diagonal
    let len = Math.hypot(moveX, moveY);
    if (len > 1) {
      moveX /= len;
      moveY /= len;
    }

    // Calculate new position (relative to player angle)
    let dirX = Math.cos(player.angle);
    let dirY = Math.sin(player.angle);
    // Move in the direction player presses, rotated by player angle
    let newX = player.x + (dirX * moveX - dirY * moveY) * moveSpeed;
    let newY = player.y + (dirY * moveX + dirX * moveY) * moveSpeed;

    if (isWalkable(newX, player.y)) player.x = newX;
    if (isWalkable(player.x, newY)) player.y = newY;
  }

  // Simple render - just clear background for now
  function render() {
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, width, height);
  }

  // Draw minimap
  function drawMinimap() {
    mmCtx.clearRect(0, 0, minimap.width, minimap.height);
    const scale = minimap.width / (mapWidth * tileSize);

    // Draw map tiles
    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        mmCtx.fillStyle = map[y][x] === 1 ? 'white' : 'black';
        mmCtx.fillRect(x * tileSize * scale, y * tileSize * scale, tileSize * scale, tileSize * scale);
      }
    }

    // Draw player on minimap
    mmCtx.fillStyle = 'cyan';
    mmCtx.beginPath();
    mmCtx.arc(player.x * scale, player.y * scale, player.radius * scale, 0, 2 * Math.PI);
    mmCtx.fill();

    // Player direction line
    mmCtx.strokeStyle = 'cyan';
    mmCtx.beginPath();
    mmCtx.moveTo(player.x * scale, player.y * scale);
    mmCtx.lineTo(player.x * scale + Math.cos(player.angle) * 20, player.y * scale + Math.sin(player.angle) * 20);
    mmCtx.stroke();
  }

  // Joystick touch controls
  let joystickActive = false;
  let joystickCenter = { x: 0, y: 0 };
  let joystickPos = { x: 0, y: 0 };

  joystickBase.addEventListener('touchstart', e => {
    e.preventDefault();
    joystickActive = true;
    const rect = joystickBase.getBoundingClientRect();
    joystickCenter.x = rect.left + rect.width / 2;
    joystickCenter.y = rect.top + rect.height / 2;
    joystickPos.x = joystickCenter.x;
    joystickPos.y = joystickCenter.y;
  });

  joystickBase.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!joystickActive) return;
    let touch = e.touches[0];
    let dx = touch.clientX - joystickCenter.x;
    let dy = touch.clientY - joystickCenter.y;
    let distance = Math.min(Math.hypot(dx, dy), 50);
    let angle = Math.atan2(dy, dx);

    joystickPos.x = joystickCenter.x + Math.cos(angle) * distance;
    joystickPos.y = joystickCenter.y + Math.sin(angle) * distance;

    joystickKnob.style.left = (joystickPos.x - joystickBase.getBoundingClientRect().left - joystickKnob.offsetWidth / 2) + 'px';
    joystickKnob.style.top = (joystickPos.y - joystickBase.getBoundingClientRect().top - joystickKnob.offsetHeight / 2) + 'px';

    player.moveX = Math.cos(angle) * (distance / 50);
    player.moveY = Math.sin(angle) * (distance / 50);
  });

  joystickBase.addEventListener('touchend', e => {
    e.preventDefault();
    joystickActive = false;
    joystickKnob.style.left = '50%';
    joystickKnob.style.top = '50%';
    player.moveX = 0;
    player.moveY = 0;
  });

  // Touch look on right side
  let lookActive = false;
  let lastTouchId = null;
  const lookSensitivity = 0.0035;

  canvas.addEventListener('touchstart', e => {
    for (let t of e.touches) {
      if (t.clientX > width / 2) {
        lookActive = true;
        lastTouchId = t.identifier;
        break;
      }
    }
  });

  canvas.addEventListener('touchmove', e => {
    if (!lookActive) return;
    for (let t of e.touches) {
      if (t.identifier === lastTouchId) {
        let dx = t.clientX - (lastTouchIdX || t.clientX);
        player.angle = normalizeAngle(player.angle + dx * lookSensitivity);
        lastTouchIdX = t.clientX;
        break;
      }
    }
  });

  canvas.addEventListener('touchend', e => {
    for (let t of e.changedTouches) {
      if (t.identifier === lastTouchId) {
        lookActive = false;
        lastTouchId = null;
        lastTouchIdX = null;
      }
    }
  });

  // Shoot and reload buttons
  function shoot() {
    if (player.ammo <= 0 || player.reloading) return;
    player.ammo--;
    ammoDisplay.textContent = player.ammo;
    // (Add shooting logic here)
  }

  function reload() {
    if (player.reloading || player.ammo === player.ammoMax) return;
    player.reloading = true;
    player.reloadTimer = 2.0;
    reloadStatus.textContent = 'Reloading...';
  }

  shootButton.addEventListener('click', shoot);
  shootButton.addEventListener('touchstart', e => { e.preventDefault(); shoot(); });

  reloadButton.addEventListener('click', reload);
  reloadButton.addEventListener('touchstart', e => { e.preventDefault(); reload(); });

  // Resize handling
  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  });

  // Game loop
  let lastTime = performance.now();

  function loop(time) {
    let dt = (time - lastTime) / 1000;
    lastTime = time;

    // Reload timer update
    if (player.reloading) {
      player.reloadTimer -= dt;
      if (player.reloadTimer <= 0) {
        player.reloading = false;
        player.ammo = player.ammoMax;
        ammoDisplay.textContent = player.ammo;
        reloadStatus.textContent = '';
      }
    }

    updatePlayer(dt);
    render();
    drawMinimap();

    healthDisplay.textContent = 'Health: ' + player.health;
    ammoDisplay.textContent = 'Ammo: ' + player.ammo;

    requestAnimationFrame(loop);
  }

  loop(lastTime);

})();
</script>

</body>
</html>
