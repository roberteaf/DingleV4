<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Balloon Tower Defense — Infinite Fun</title>
  <style>
    :root{--bg:#071022;--panel:#091426;--accent:#ffd166;--muted:#9fb0c8;--card:rgba(255,255,255,0.04)}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:radial-gradient(circle at 20% 10%, #0b2a4a 0%, #071022 40%, #04101a 100%);color:#eaf6ff}
    .wrap{display:flex;gap:14px;align-items:flex-start;padding:16px;max-width:1280px;margin:0 auto}
    canvas{background:linear-gradient(180deg,#9fe1ff,#bdf0ff);border-radius:12px;box-shadow:0 14px 40px rgba(0,0,0,.6)}
    .sidebar{width:360px;background:linear-gradient(180deg,var(--panel),#071327);border-radius:12px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.5)}
    h1{margin:0 0 10px;font-size:20px}
    .row{display:flex;gap:8px;margin-bottom:8px}
    .stat{flex:1;padding:10px;background:var(--card);border-radius:8px;text-align:center}
    .btn{padding:8px 10px;border-radius:8px;background:linear-gradient(180deg,#0f2436,#0b1520);border:1px solid rgba(255,255,255,.03);cursor:pointer}
    .tower-list{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
    .tower-card{padding:10px;background:linear-gradient(180deg,#071827,#072433);border-radius:8px;cursor:pointer;border:1px solid rgba(255,255,255,.02);text-align:center}
    .tower-card.selected{outline:2px solid var(--accent)}
    .log{height:120px;overflow:auto;padding:8px;background:rgba(0,0,0,.12);border-radius:8px;font-size:13px}
    .small{font-size:13px;color:var(--muted)}
    .controls{display:flex;gap:8px;margin-bottom:8px}
    .footer{font-size:12px;color:var(--muted);margin-top:10px}
    .title-row{display:flex;justify-content:space-between;align-items:center}
    .hud{display:flex;gap:8px;align-items:center}
    .badge{background:rgba(255,255,255,.04);padding:6px 8px;border-radius:8px}
    .center{display:flex;flex-direction:column;align-items:center}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="920" height="620"></canvas>
    <div class="sidebar">
      <div class="title-row"><h1>Balloon TD — Infinite Rounds</h1><div class="badge small">Endless • Casual • Fun</div></div>

      <div class="row">
        <div class="stat"><div class="small">Money</div><div id="money">200</div></div>
        <div class="stat"><div class="small">Lives</div><div id="lives">30</div></div>
        <div class="stat"><div class="small">Wave</div><div id="wave">0</div></div>
      </div>

      <div class="small">Shop: Click a tower then click the map to place. Towers can be upgraded. Survive as many waves as you can — difficulty scales infinitely.</div>

      <div class="tower-list" id="towerList"></div>

      <div class="controls">
        <button class="btn" id="startWave">Start Wave</button>
        <button class="btn" id="pauseBtn">Pause</button>
        <button class="btn" id="fastBtn">x1</button>
      </div>

      <div class="row">
        <div class="btn" id="upgradeBtn">Upgrade</div>
        <div class="btn" id="sellBtn">Sell</div>
        <div class="btn" id="restartBtn">Restart</div>
      </div>

      <div style="margin-top:10px"><strong>Score</strong><div class="log" id="log"></div></div>

      <div class="footer">Made for fun — single file. Want more maps, balance tweaks, or web-publishable build? I can do that next.</div>
    </div>
  </div>

<script>
// --- Balloon Tower Defense: Infinite rounds, more towers, polished animations ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const MONEY_EL = document.getElementById('money');
const LIVES_EL = document.getElementById('lives');
const WAVE_EL = document.getElementById('wave');
const LOG = document.getElementById('log');

let money = 200, lives = 30, wave = 0, running = true, timeScale = 1, waveActive = false;
let score = 0;
function log(msg){ const t = new Date().toLocaleTimeString(); LOG.innerHTML = `<div>[${t}] ${msg}</div>` + LOG.innerHTML; }

// Path (waypoints)
const path = [ {x:-40,y:340}, {x:140,y:340}, {x:140,y:140}, {x:360,y:140}, {x:360,y:460}, {x:660,y:460}, {x:860,y:460} ];

// State
let balloons = []; let towers = []; let projectiles = []; let particles = []; let floating = [];
let selectedType = null; let selectedTower = null;

// Tower templates
const TEMPLATES = {
  basic:{id:'basic',name:'Basic',cost:40,range:110,fireRate:1.2,damage:12,projSpeed:420,aoe:0,desc:'Reliable rapid shooter.'},
  rapid:{id:'rapid',name:'Rapid',cost:70,range:90,fireRate:3.5,damage:6,projSpeed:480,aoe:0,desc:'High fire-rate close-range.'},
  cannon:{id:'cannon',name:'Cannon',cost:120,range:140,fireRate:0.7,damage:28,projSpeed:380,aoe:36,desc:'Splash damage; great vs groups.'},
  sniper:{id:'sniper',name:'Sniper',cost:160,range:420,fireRate:0.9,damage:70,projSpeed:900,aoe:0,desc:'High single-target damage.'},
  freeze:{id:'freeze',name:'Freeze',cost:130,range:140,fireRate:0.8,damage:0,projSpeed:0,slow:0.6,duration:1.6,desc:'Slows balloons in range.'},
  laser:{id:'laser',name:'Laser',cost:220,range:200,fireRate:0.15,damage:18,projSpeed:2000,beam:true,desc:'Continuous beam; pierces.'}
};

// Balloons types
const BALLOON_TYPES = [
  {name:'Normal',hp:20,speed:0.8,reward:6,color:'#ff6b6b'},
  {name:'Fast',hp:12,speed:1.6,reward:8,color:'#ffd166'},
  {name:'Armored',hp:70,speed:0.6,reward:18,color:'#d4d4d8',armor:0.6},
  {name:'Regenerate',hp:30,speed:0.9,reward:12,color:'#7efc7e',regen:0.2},
  {name:'Boss',hp:500,speed:0.5,reward:200,color:'#c084fc',boss:true}
];

// Helpers
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

// Classes
class Balloon{ constructor(type){ this.type=type; this.maxHp=type.hp; this.hp=this.maxHp; this.speed=type.speed; this.reward=type.reward; this.x=path[0].x; this.y=path[0].y; this.idx=0; this.finished=false; this.slow=1; this.slowT=0; }
  update(dt){ if(this.finished) return; // movement
    if(this.slowT>0) this.slowT = Math.max(0,this.slowT - dt);
    else this.slow = 1;
    const move = dt * this.speed * 60 * this.slow;
    let rem = move;
    while(rem>0 && this.idx < path.length-1){ const nx=path[this.idx+1].x, ny=path[this.idx+1].y; const d = Math.hypot(nx-this.x, ny-this.y); if(d <= rem){ this.x = nx; this.y = ny; this.idx++; rem -= d; } else { const r = rem/d; this.x += (nx-this.x)*r; this.y += (ny-this.y)*r; rem = 0; } }
    if(this.idx >= path.length-1) { this.finished=true; }
    // regen
    if(this.type.regen){ this.hp = Math.min(this.maxHp, this.hp + (this.type.regen*dt*8)); }
  }
}

class Tower{ constructor(x,y,template){ this.x=x; this.y=y; this.tpl=template; this.cool=0; this.level=1; this.props = JSON.parse(JSON.stringify(template)); }
  update(dt){ if(this.cool>0) this.cool -= dt * timeScale; // laser is special
    if(this.tpl.beam){ // find closest in range
      let targets = balloons.filter(b=>!b.finished && b.hp>0 && dist(this.x,this.y,b.x,b.y) <= this.props.range);
      if(targets.length){ const t = targets[0]; // deal damage per second
        t.hp -= this.props.damage * dt * timeScale; spawnBeam(this,this.x,this.y,t.x,t.y); }
    }
    else if(this.cool <= 0){ // find target
      let target = null; let best = Infinity;
      for(const b of balloons){ if(b.finished || b.hp<=0) continue; const d = dist(this.x,this.y,b.x,b.y); if(d <= this.props.range){ if(d < best){ best=d; target=b; } } }
      if(target){ this.fire(target); this.cool = 1/this.props.fireRate; }
    }
  }
  fire(target){ if(this.tpl.beam) return; if(this.tpl.slow){ // apply slow aura
      // Apply slow to targets in small radius
      for(const b of balloons){ const d = dist(this.x,this.y,b.x,b.y); if(d <= this.props.range){ b.slow = this.props.slow; b.slowT = this.props.duration; spawnParticles(b.x,b.y,6,'#9be7ff'); } }
      log('Freeze pulse!'); return; }
    const dx = target.x - this.x, dy = target.y - this.y; const ang = Math.atan2(dy,dx);
    if(this.tpl.aoe){ // cannon: create projectile with aoe
      projectiles.push(new Projectile(this.x,this.y,target,this.props.damage,this.props.projSpeed,this.props.aoe,ang));
    } else {
      projectiles.push(new Projectile(this.x,this.y,target,this.props.damage,this.props.projSpeed,0,ang));
    }
    spawnMuzzle(this.x,this.y,ang);
  }
}

class Projectile{ constructor(x,y,target,damage,speed,aoe,angle){ this.x=x; this.y=y; this.target=target; this.damage=damage; this.speed=speed; this.aoe=aoe; this.angle=angle; this.dead=false; }
  update(dt){ if(this.dead) return; if(!this.target || this.target.finished){ this.dead=true; return; }
    const dx=this.target.x-this.x, dy=this.target.y-this.y; const d=Math.hypot(dx,dy); const step = this.speed * dt * 60 * timeScale;
    if(d <= step || d===0){ // hit
      if(this.aoe>0){ // splash
        for(const b of balloons){ if(b.finished || b.hp<=0) continue; const dd=dist(this.x,this.y,b.x,b.y); if(dd <= this.aoe){ b.hp -= this.damage * (b.type.armor? b.type.armor : 1); spawnParticles(b.x,b.y,8,'#ffd1a8'); if(b.hp<=0){ money += b.reward; score += b.reward; floating.push(new Floating('+'+b.reward,b.x,b.y,'#ffd166')); } }
        }
      } else { this.target.hp -= this.damage * (this.target.type.armor? this.target.type.armor : 1); spawnParticles(this.target.x,this.target.y,6,'#ff7f7f'); if(this.target.hp <= 0){ money += this.target.reward; score += this.target.reward; floating.push(new Floating('+'+this.target.reward,this.target.x,this.target.y,'#ffd166')); } }
      this.dead=true;
    } else { this.x += dx/d*step; this.y += dy/d*step; }
  }
}

class Particle{ constructor(x,y,dx,dy,l,clr){ this.x=x;this.y=y;this.dx=dx;this.dy=dy;this.l=l;this.clr=clr; }
  update(dt){ this.x += this.dx*dt*60; this.y += this.dy*dt*60; this.l -= dt*1.8; }
}
class Floating{ constructor(text,x,y,clr){ this.text=text; this.x=x; this.y=y; this.vy=-0.6; this.life=1.2; this.clr=clr; }
  update(dt){ this.y += this.vy*dt*60; this.life -= dt; }
}

// Utils
function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }

// Spawning
function spawnWave(n){ waveActive = true; wave++; WAVE_EL.textContent = wave; log(`Wave ${wave} started`);
  const base = Math.floor(6 + wave*1.4);
  const count = base + Math.floor(wave*0.8);
  let spawned=0; let interval = Math.max(220, 900 - Math.floor(wave*6));
  // schedule variety
  const timer = setInterval(()=>{
    if(spawned >= count){ clearInterval(timer); waveActive = false; log(`Wave ${wave} ended`); return; }
    // choose type
    let typeRoll = Math.random(); let ttpl = BALLOON_TYPES[0];
    if(Math.random() < clamp(wave/80,0,0.35)) ttpl = BALLOON_TYPES[4];
    else if(typeRoll < 0.12 + wave*0.01) ttpl = BALLOON_TYPES[2];
    else if(typeRoll < 0.28) ttpl = BALLOON_TYPES[1];
    else if(typeRoll < 0.45) ttpl = BALLOON_TYPES[3];
    // scale HP by wave
    const clone = Object.assign({}, ttpl, {hp: Math.ceil(ttpl.hp * (1 + wave*0.12)) ,reward: Math.ceil(ttpl.reward * (1 + wave*0.06))});
    balloons.push(new Balloon(clone)); spawned++; }, interval / timeScale);
}

// Visual spawns
function spawnParticles(x,y,num,clr){ for(let i=0;i<num;i++){ const ang = Math.random()*Math.PI*2; const speed = rand(0.6,3.2); particles.push(new Particle(x,y,Math.cos(ang)*speed,Math.sin(ang)*speed,rand(0.6,1.6),clr)); } }
function spawnMuzzle(x,y,ang){ for(let i=0;i<6;i++){ const a = ang + rand(-0.6,0.6); particles.push(new Particle(x+Math.cos(ang)*14,y+Math.sin(ang)*14,Math.cos(a)*rand(2,6),Math.sin(a)*rand(2,6),rand(0.4,0.9),'#fff')); } }
function spawnBeam(t,x1,y1,x2,y2){ // cosmetic: draw line during render by storing on tower
  t._beam = {x2,y2,age:0.06}; }

// Rendering
function drawPath(){ ctx.save(); ctx.lineWidth=20; ctx.lineCap='round'; ctx.strokeStyle='#6d3b15'; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y); ctx.stroke(); ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y); ctx.stroke(); ctx.restore(); }

function render(){ ctx.clearRect(0,0,canvas.width,canvas.height);
  drawPath();
  // towers
  for(const t of towers){ // base
    ctx.save(); ctx.translate(t.x,t.y);
    // range pulse when selected
    if(t===selectedTower){ ctx.beginPath(); ctx.strokeStyle='rgba(255,209,102,0.12)'; ctx.lineWidth=2; ctx.arc(0,0,t.props.range,0,Math.PI*2); ctx.stroke(); }
    // body
    ctx.beginPath(); ctx.fillStyle='#20323f'; ctx.arc(0,0,16,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#0f7fbf'; ctx.lineWidth=2; ctx.stroke();
    // turret
    ctx.rotate((performance.now()/500)%Math.PI*2);
    ctx.fillStyle='#cbd5e1'; ctx.fillRect(6,-6,18,12);
    ctx.restore();
    // beam
    if(t.tpl.beam && t._beam){ const b=t._beam; const alpha = clamp(b.age/0.06,0,1); ctx.beginPath(); ctx.strokeStyle=`rgba(200,120,255,${alpha})`; ctx.lineWidth=4; ctx.moveTo(t.x,t.y); ctx.lineTo(b.x2,b.y2); ctx.stroke(); t._beam.age -= 0.016; if(t._beam.age<=0) t._beam=null; }
  }
  // balloons
  for(const b of balloons){ if(b.finished) continue; const hpRatio = clamp(b.hp/b.maxHp,0,1); ctx.beginPath(); // body
    const grad = ctx.createLinearGradient(b.x-12,b.y-12,b.x+12,b.y+12);
    grad.addColorStop(0,b.type.color); grad.addColorStop(1,'#ffffff'); ctx.fillStyle = grad; ctx.strokeStyle='#00000020'; ctx.lineWidth=2; ctx.arc(b.x,b.y,12,0,Math.PI*2); ctx.fill(); ctx.stroke(); // hp bar
    ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(b.x-12,b.y-20,24,4); ctx.fillStyle='#7efc7e'; ctx.fillRect(b.x-12,b.y-20,24*hpRatio,4);
  }
  // projectiles
  for(const p of projectiles){ ctx.beginPath(); ctx.fillStyle='#fff'; ctx.arc(p.x,p.y,p.aoe?6:4,0,Math.PI*2); ctx.fill(); if(p.aoe){ ctx.beginPath(); ctx.strokeStyle='rgba(255,160,80,0.12)'; ctx.lineWidth=2; ctx.arc(p.x,p.y,p.aoe,0,Math.PI*2); ctx.stroke(); } }
  // particles
  for(const q of particles){ ctx.beginPath(); ctx.fillStyle=q.clr; ctx.globalAlpha = clamp(q.l,0,1); ctx.arc(q.x,q.y,Math.max(1,q.l*3),0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
  // floating text
  ctx.font = '14px system-ui'; ctx.textAlign='center'; for(const f of floating){ ctx.fillStyle=f.clr; ctx.globalAlpha = clamp(f.life,0,1); ctx.fillText(f.text,f.x,f.y); ctx.globalAlpha=1; }
  // HUD small overlay
  ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(8,8,220,48); ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.textAlign='left'; ctx.fillText(`Score: ${score}`,16,28); ctx.fillText(`Towers: ${towers.length}`,16,44);
}

// Game loop
let last = performance.now(); function loop(now){ if(!running){ requestAnimationFrame(loop); last = now; return; }
  const dt = Math.min(0.04,(now-last)/1000) * timeScale; last = now;
  // update
  for(const b of balloons) b.update(dt);
  for(const t of towers) t.update(dt);
  for(const p of projectiles) p.update(dt);
  for(let i=particles.length-1;i>=0;i--){ particles[i].update(dt); if(particles[i].l <= 0) particles.splice(i,1); }
  for(let i=floating.length-1;i>=0;i--){ floating[i].update(dt); if(floating[i].life <= 0) floating.splice(i,1); }
  // cleanup balloons
  for(let i=balloons.length-1;i>=0;i--){ const b=balloons[i]; if(b.finished){ balloons.splice(i,1); lives -=1; log('A balloon slipped through! -1 life'); LIVES_EL.textContent = lives; if(lives<=0){ gameOver(); } }
    else if(b.hp <=0){ balloons.splice(i,1); }
  }
  for(let i=projectiles.length-1;i>=0;i--) if(projectiles[i].dead) projectiles.splice(i,1);
  // rendering
  render(); requestAnimationFrame(loop);
}

// Input & UI
canvas.addEventListener('click',(e)=>{ const rect=canvas.getBoundingClientRect(); const x=(e.clientX-rect.left)*(canvas.width/rect.width); const y=(e.clientY-rect.top)*(canvas.height/rect.height);
  if(selectedType){ // try place
    if(canPlace(x,y)){ const cost = TEMPLATES[selectedType].cost; if(money >= cost){ towers.push(new Tower(x,y,TEMPLATES[selectedType])); money -= cost; log(`${TEMPLATES[selectedType].name} placed (-${cost})`); updateUI(); } else log('Not enough money'); selectedType=null; renderTowerList(); }
    else { log('Cannot place on path or too close to another tower'); selectedType=null; renderTowerList(); }
    return; }
  // select tower
  let found = null; for(const t of towers){ if(Math.hypot(t.x-x,t.y-y) <= 18) { found=t; break; } }
  selectedTower = found; if(found) log(`${found.tpl.name} selected`);
});

function canPlace(x,y){ // not on path (distance to segment)
  for(let i=0;i<path.length-1;i++){ const a=path[i], b=path[i+1]; if(distToSegment({x,y},a,b) < 28) return false; }
  for(const t of towers) if(Math.hypot(t.x-x,t.y-y) < 36) return false; return true; }
function distToSegment(p,a,b){ const vx=b.x-a.x, vy=b.y-a.y; const wx=p.x-a.x, wy=p.y-a.y; const c=(vx*wx+vy*wy); const d=vx*vx+vy*vy; let t=(d===0)?0:c/d; if(t<0) t=0; if(t>1) t=1; const projx=a.x+vx*t, projy=a.y+vy*t; return Math.hypot(p.x-projx,p.y-projy); }

// Buttons
const towerListDiv = document.getElementById('towerList'); function renderTowerList(){ towerListDiv.innerHTML=''; for(const k in TEMPLATES){ const tpl=TEMPLATES[k]; const div = document.createElement('div'); div.className='tower-card'+(selectedType===tpl.id?' selected':''); div.innerHTML = `<strong>${tpl.name}</strong><div class="small">${tpl.desc}</div><div class="small">Cost: ${tpl.cost}</div>`; div.onclick = ()=>{ selectedType = tpl.id; selectedTower=null; renderTowerList(); log(`${tpl.name} selected for placement`); }; towerListDiv.appendChild(div); } }
renderTowerList();

document.getElementById('startWave').addEventListener('click',()=>{ if(!waveActive) spawnWave(wave+1); });
document.getElementById('pauseBtn').addEventListener('click',function(){ running = !running; this.textContent = running? 'Pause' : 'Resume'; });
document.getElementById('fastBtn').addEventListener('click',function(){ timeScale = timeScale===1?2:1; this.textContent = timeScale===1? 'x1' : 'x2'; });
document.getElementById('restartBtn').addEventListener('click',()=>{ resetGame(); });
document.getElementById('upgradeBtn').addEventListener('click',()=>{ if(!selectedTower){ log('No tower selected'); return; } const cost = Math.floor(selectedTower.tpl.cost * (1.8 + selectedTower.level*0.6)); if(money < cost){ log('Not enough money to upgrade'); return; } money -= cost; selectedTower.level++; selectedTower.props.damage = Math.ceil(selectedTower.props.damage*1.45); selectedTower.props.range += 14; selectedTower.props.fireRate *= 1.12; log(`${selectedTower.tpl.name} upgraded to L${selectedTower.level} (-${cost})`); updateUI(); });
document.getElementById('sellBtn').addEventListener('click',()=>{ if(!selectedTower){ log('No tower selected'); return; } const idx=towers.indexOf(selectedTower); if(idx>=0){ const rec = Math.floor(selectedTower.tpl.cost * (0.5 + selectedTower.level*0.1)); money += rec; towers.splice(idx,1); selectedTower=null; log(`Tower sold +${rec}`); updateUI(); } });

function updateUI(){ MONEY_EL.textContent = Math.max(0,Math.floor(money)); LIVES_EL.textContent = Math.max(0,lives); WAVE_EL.textContent = wave; }

function resetGame(){ money=200; lives=30; wave=0; score=0; balloons=[]; projectiles=[]; towers=[]; particles=[]; floating=[]; selectedTower=null; selectedType=null; renderTowerList(); updateUI(); log('Game reset'); }

function gameOver(){ log('GAME OVER — You made it to wave '+wave+". Press Restart to try again."); running=false; }

// initial
updateUI(); requestAnimationFrame(loop);

</script>
</body>
</html>
