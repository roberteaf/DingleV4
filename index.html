<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bee Swarm Simulator 3D - Enhanced Edition</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #shop {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        button {
            background: #FFD700;
            border: none;
            padding: 5px 10px;
            margin: 5px;
            cursor: pointer;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <p>Pollen: <span id="pollen">0</span></p>
        <p>Honey: <span id="honey">0</span></p>
        <p>Bees: <span id="bees-count">5</span></p>
        <p>Level: <span id="level">1</span></p>
    </div>
    <div id="controls">
        <p>Controls:</p>
        <p>Keyboard: WASD/Arrows to move, Space to jump/collect.</p>
        <p>Mobile: Touch joystick area (left) to move, right to jump.</p>
        <p>Gamepad: Left stick move, A button jump.</p>
        <p>Press 'P' to open/close shop.</p>
    </div>
    <div id="shop">
        <h3>Shop</h3>
        <button id="buy-bee">Buy Bee (100 Honey)</button>
        <button id="upgrade-collector">Upgrade Collector (200 Honey)</button>
        <button id="buy-hive">Upgrade Hive (500 Honey)</button>
        <button id="close-shop">Close</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Ground (field with texture simulation)
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Skybox
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Player (collector - simple backpack model)
        const playerGroup = new THREE.Group();
        const bodyGeometry = new THREE.BoxGeometry(1, 2, 1);
        const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1;
        playerGroup.add(body);

        const headGeometry = new THREE.SphereGeometry(0.6, 32, 32);
        const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 2.2;
        playerGroup.add(head);

        playerGroup.position.y = 0;
        scene.add(playerGroup);
        camera.position.set(0, 5, 15);
        camera.lookAt(playerGroup.position);

        // Hive
        const hiveGeometry = new THREE.CylinderGeometry(2, 2, 3, 32);
        const hiveMaterial = new THREE.MeshLambertMaterial({ color: 0xDAA520 });
        const hive = new THREE.Mesh(hiveGeometry, hiveMaterial);
        hive.position.set(0, 1.5, -20);
        scene.add(hive);

        // Bees
        const bees = [];
        let beeCount = 5;
        let beeSpeed = 0.05;
        for (let i = 0; i < beeCount; i++) {
            createBee();
        }

        function createBee() {
            const beeGroup = new THREE.Group();
            const beeBody = new THREE.SphereGeometry(0.4, 32, 32);
            const beeMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
            const bee = new THREE.Mesh(beeBody, beeMaterial);
            beeGroup.add(bee);

            // Wings
            const wingGeometry = new THREE.PlaneGeometry(0.5, 0.3);
            const wingMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.4, 0.2, 0);
            leftWing.rotation.z = Math.PI / 4;
            beeGroup.add(leftWing);
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.4, 0.2, 0);
            rightWing.rotation.z = -Math.PI / 4;
            beeGroup.add(rightWing);

            beeGroup.position.set(Math.random() * 20 - 10, 2 + Math.random() * 2, Math.random() * 20 - 10 - 20);
            scene.add(beeGroup);
            bees.push({ group: beeGroup, target: null, leftWing, rightWing, animationTime: Math.random() * 1000 });
        }

        // Flowers
        const flowers = [];
        let flowerCount = 20;
        for (let i = 0; i < flowerCount; i++) {
            createFlower();
        }

        function createFlower() {
            const flowerGroup = new THREE.Group();
            const stemGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 32);
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x008000 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 1;
            flowerGroup.add(stem);

            const petalGeometry = new THREE.CircleGeometry(0.5, 32);
            const petalMaterial = new THREE.MeshLambertMaterial({ color: 0xFF69B4, side: THREE.DoubleSide });
            for (let j = 0; j < 5; j++) {
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                petal.position.y = 2;
                petal.position.x = Math.cos(j * 2 * Math.PI / 5) * 0.3;
                petal.position.z = Math.sin(j * 2 * Math.PI / 5) * 0.3;
                petal.rotation.x = Math.PI / 2;
                flowerGroup.add(petal);
            }

            const centerGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const centerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.y = 2;
            flowerGroup.add(center);

            flowerGroup.position.set(Math.random() * 100 - 50, 0, Math.random() * 100 - 50);
            scene.add(flowerGroup);
            flowers.push(flowerGroup);
        }

        // Particles for pollen
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(1000 * 3);
        const particleMaterial = new THREE.PointsMaterial({ color: 0xFFD700, size: 0.1 });
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        particles.visible = false;
        scene.add(particles);

        function showPollenParticles(position) {
            for (let i = 0; i < 1000; i += 3) {
                particlePositions[i] = position.x + (Math.random() - 0.5) * 1;
                particlePositions[i + 1] = position.y + (Math.random() - 0.5) * 1 + 1;
                particlePositions[i + 2] = position.z + (Math.random() - 0.5) * 1;
            }
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particles.position.set(0, 0, 0);
            particles.visible = true;
            setTimeout(() => { particles.visible = false; }, 1000);
        }

        // Game variables
        let pollen = 0;
        let honey = 0;
        let level = 1;
        let collectorCapacity = 10;
        let hiveCapacity = 100;
        let playerPollen = 0;
        let jumpVelocity = 0;
        let isJumping = false;
        let gravity = -0.02;

        // Controls
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') jump();
            if (e.key.toLowerCase() === 'p') toggleShop();
        });
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        // Mobile touch controls
        let moveTouchId = null;
        let jumpTouchId = null;
        let touchMoveX = 0, touchMoveY = 0;
        window.addEventListener('touchstart', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.clientX < window.innerWidth / 2 && !moveTouchId) {
                    moveTouchId = touch.identifier;
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                } else if (touch.clientX >= window.innerWidth / 2 && !jumpTouchId) {
                    jumpTouchId = touch.identifier;
                    jump();
                }
            }
        });
        window.addEventListener('touchmove', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === moveTouchId) {
                    touchMoveX = touch.clientX - touchStartX;
                    touchMoveY = touch.clientY - touchStartY;
                }
            }
        });
        window.addEventListener('touchend', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === moveTouchId) {
                    moveTouchId = null;
                    touchMoveX = 0;
                    touchMoveY = 0;
                } else if (touch.identifier === jumpTouchId) {
                    jumpTouchId = null;
                }
            }
        });

        // Gamepad support
        let gamepad;
        window.addEventListener('gamepadconnected', (e) => {
            gamepad = navigator.getGamepads()[e.gamepad.index];
        });

        function jump() {
            if (!isJumping) {
                jumpVelocity = 0.5;
                isJumping = true;
            }
        }

        // Shop
        const shopDiv = document.getElementById('shop');
        function toggleShop() {
            shopDiv.style.display = shopDiv.style.display === 'none' ? 'block' : 'none';
        }

        document.getElementById('buy-bee').addEventListener('click', () => {
            if (honey >= 100) {
                honey -= 100;
                beeCount++;
                createBee();
                updateUI();
            }
        });

        document.getElementById('upgrade-collector').addEventListener('click', () => {
            if (honey >= 200) {
                honey -= 200;
                collectorCapacity += 5;
                updateUI();
            }
        });

        document.getElementById('buy-hive').addEventListener('click', () => {
            if (honey >= 500) {
                honey -= 500;
                hiveCapacity += 50;
                beeSpeed += 0.01;
                updateUI();
            }
        });

        document.getElementById('close-shop').addEventListener('click', toggleShop);

        // Update UI
        function updateUI() {
            document.getElementById('pollen').textContent = pollen;
            document.getElementById('honey').textContent = honey;
            document.getElementById('bees-count').textContent = beeCount;
            document.getElementById('level').textContent = level;
        }

        // Bee AI and animation
        function animateBees() {
            bees.forEach((beeObj, index) => {
                const bee = beeObj.group;
                beeObj.animationTime += 0.1;
                beeObj.leftWing.rotation.z = Math.PI / 4 + Math.sin(beeObj.animationTime * 10) * 0.2;
                beeObj.rightWing.rotation.z = -Math.PI / 4 - Math.sin(beeObj.animationTime * 10) * 0.2;

                if (!beeObj.target || Math.random() < 0.01) {
                    const randomFlower = flowers[Math.floor(Math.random() * flowers.length)];
                    beeObj.target = randomFlower.position.clone();
                }

                const direction = beeObj.target.clone().sub(bee.position).normalize();
                bee.position.add(direction.multiplyScalar(beeSpeed));

                bee.lookAt(beeObj.target);

                if (bee.position.distanceTo(beeObj.target) < 1) {
                    pollen += 1;
                    showPollenParticles(beeObj.target);
                    beeObj.target = hive.position.clone();
                }

                if (bee.position.distanceTo(hive.position) < 2 && beeObj.target.equals(hive.position)) {
                    if (pollen >= hiveCapacity) {
                        honey += hiveCapacity;
                        pollen -= hiveCapacity;
                        levelUp();
                    } else {
                        honey += pollen;
                        pollen = 0;
                        levelUp();
                    }
                    beeObj.target = null;
                }
            });
        }

        function levelUp() {
            if (honey >= level * 1000) {
                level++;
                beeSpeed += 0.005;
                collectorCapacity += 2;
            }
            updateUI();
        }

        // Player collection
        function collectPollen() {
            flowers.forEach((flower, index) => {
                const distance = playerGroup.position.distanceTo(flower.position);
                if (distance < 3 && playerPollen < collectorCapacity) {
                    playerPollen += 1;
                    showPollenParticles(flower.position);
                    flower.position.set(Math.random() * 100 - 50, 0, Math.random() * 100 - 50);
                    if (playerPollen >= collectorCapacity) {
                        console.log('Collector full! Return to hive.');
                    }
                }
            });

            const hiveDistance = playerGroup.position.distanceTo(hive.position);
            if (hiveDistance < 5 && playerPollen > 0) {
                pollen += playerPollen;
                playerPollen = 0;
            }
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            const delta = time - lastTime;
            lastTime = time;

            // Player movement
            const speed = 0.3;
            let moveX = 0, moveZ = 0;

            if (keys['w'] || keys['ArrowUp']) moveZ -= speed;
            if (keys['s'] || keys['ArrowDown']) moveZ += speed;
            if (keys['a'] || keys['ArrowLeft']) moveX -= speed;
            if (keys['d'] || keys['ArrowRight']) moveX += speed;

            // Normalize diagonal movement
            if (moveX !== 0 && moveZ !== 0) {
                moveX /= Math.sqrt(2);
                moveZ /= Math.sqrt(2);
            }

            playerGroup.position.x += moveX;
            playerGroup.position.z += moveZ;

            // Touch movement
            playerGroup.position.x += touchMoveX * 0.005;
            playerGroup.position.z += touchMoveY * 0.005;

            // Gamepad movement
            if (gamepad) {
                gamepad = navigator.getGamepads()[0]; // Update
                if (gamepad) {
                    const axes = gamepad.axes;
                    playerGroup.position.x += axes[0] * speed;
                    playerGroup.position.z += axes[1] * speed;
                    if (gamepad.buttons[0].pressed) jump();
                }
            }

            // Jumping
            playerGroup.position.y += jumpVelocity;
            jumpVelocity += gravity;
            if (playerGroup.position.y <= 0) {
                playerGroup.position.y = 0;
                jumpVelocity = 0;
                isJumping = false;
            }

            // Camera follow
            camera.position.x = playerGroup.position.x;
            camera.position.y = playerGroup.position.y + 5;
            camera.position.z = playerGroup.position.z + 15;
            camera.lookAt(playerGroup.position);

            animateBees();
            collectPollen();
            updateUI();

            renderer.render(scene, camera);
        }
        animate(0);

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
