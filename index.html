<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple FPS Shooter (Raycasting)</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    height: 100%;
    background: #222;
    font-family: monospace;
    color: white;
  }
  #gameCanvas {
    display: block;
    background: #555;
    cursor: none; /* Hide default cursor */
  }
  #hud {
    position: fixed;
    top: 15px;
    left: 15px;
    font-size: 18px;
    user-select: none;
  }
  #crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin-left: -10px;
    margin-top: -10px;
    pointer-events: none;
    z-index: 10;
  }
  #crosshair:before, #crosshair:after {
    content: '';
    position: absolute;
    background: white;
  }
  #crosshair:before {
    left: 9px;
    top: 0;
    width: 2px;
    height: 20px;
  }
  #crosshair:after {
    top: 9px;
    left: 0;
    width: 20px;
    height: 2px;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<div id="hud">Ammo: 10</div>
<div id="crosshair"></div>

<script>
// Simple raycasting FPS shooter - vanilla JS

(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');

  // Screen size
  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  // Map config (1 = wall, 0 = empty)
  const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,0,1,1,1,0,1,0,0,1],
    [1,0,1,0,0,0,1,0,1,0,0,1],
    [1,0,1,1,1,0,1,0,1,1,0,1],
    [1,0,0,0,1,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,0,1,0,1],
    [1,0,1,0,0,0,0,1,0,1,0,1],
    [1,0,1,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1]
  ];
  const mapWidth = map[0].length;
  const mapHeight = map.length;
  const tileSize = 64;

  // Player state
  let player = {
    x: 3 * tileSize + tileSize/2,
    y: 3 * tileSize + tileSize/2,
    angle: 0, // direction facing, in radians
    speed: 0,
    turnSpeed: 0,
    radius: 10,
    ammo: 10,
  };

  // Controls state
  const keys = {};
  let mouseMovementX = 0;

  // Raycasting params
  const fov = Math.PI / 3; // 60 degrees
  const numRays = width; // one ray per pixel for highest quality
  const maxDepth = 1000;

  // Targets - enemies to shoot
  const targets = [
    {x: 6.5 * tileSize, y: 5.5 * tileSize, radius: 15, alive: true},
    {x: 8.5 * tileSize, y: 7.5 * tileSize, radius: 15, alive: true},
  ];

  // Mouse look sensitivity
  const mouseSensitivity = 0.002;

  // Game state
  let lastTime = 0;

  // Helper - clamp
  function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
  }

  // Helper - distance
  function dist(ax, ay, bx, by) {
    return Math.hypot(bx - ax, by - ay);
  }

  // Listen for keys
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  // Mouse lock and movement for pointer lock FPS
  canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
  document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;

  canvas.onclick = () => {
    if (document.pointerLockElement !== canvas) {
      canvas.requestPointerLock();
    } else if (player.ammo > 0) {
      shoot();
    }
  };

  document.addEventListener('pointerlockchange', lockChangeAlert, false);
  document.addEventListener('mozpointerlockchange', lockChangeAlert, false);

  function lockChangeAlert() {
    if (document.pointerLockElement === canvas) {
      document.addEventListener("mousemove", updateMousePosition, false);
    } else {
      document.removeEventListener("mousemove", updateMousePosition, false);
    }
  }

  function updateMousePosition(e) {
    player.angle += e.movementX * mouseSensitivity;
    player.angle = player.angle % (2 * Math.PI);
  }

  // Movement update
  function updatePlayer(dt) {
    const moveSpeed = 150; // pixels per second
    const turnSpeed = 3; // radians per second (not used, using mouse look)

    let moveStep = moveSpeed * dt;

    let dx = 0, dy = 0;

    if (keys['w']) {
      dx += Math.cos(player.angle) * moveStep;
      dy += Math.sin(player.angle) * moveStep;
    }
    if (keys['s']) {
      dx -= Math.cos(player.angle) * moveStep;
      dy -= Math.sin(player.angle) * moveStep;
    }
    if (keys['a']) {
      dx += Math.cos(player.angle - Math.PI / 2) * moveStep;
      dy += Math.sin(player.angle - Math.PI / 2) * moveStep;
    }
    if (keys['d']) {
      dx += Math.cos(player.angle + Math.PI / 2) * moveStep;
      dy += Math.sin(player.angle + Math.PI / 2) * moveStep;
    }

    // Collision check
    if (!isWall(player.x + dx, player.y)) {
      player.x += dx;
    }
    if (!isWall(player.x, player.y + dy)) {
      player.y += dy;
    }
  }

  // Check if position hits a wall
  function isWall(x, y) {
    if (x < 0 || y < 0 || x >= mapWidth * tileSize || y >= mapHeight * tileSize) return true;
    let mx = Math.floor(x / tileSize);
    let my = Math.floor(y / tileSize);
    return map[my][mx] !== 0;
  }

  // Raycasting function to render scene
  function castRays() {
    // Clear screen (floor & ceiling)
    ctx.fillStyle = '#333'; // ceiling color
    ctx.fillRect(0, 0, width, height/2);
    ctx.fillStyle = '#777'; // floor color
    ctx.fillRect(0, height/2, width, height/2);

    const stripWidth = width / numRays;
    const rayAngleStep = fov / numRays;

    for (let i = 0; i < numRays; i++) {
      // Calculate ray angle relative to player
      let rayAngle = player.angle - fov/2 + i * rayAngleStep;
      rayAngle = normalizeAngle(rayAngle);

      // Ray casting variables
      let distance = 0;
      let hit = false;
      let wallX, wallY;
      let textureX;

      const eyeX = Math.cos(rayAngle);
      const eyeY = Math.sin(rayAngle);

      while (!hit && distance < maxDepth) {
        distance += 1;
        let testX = Math.floor((player.x + eyeX * distance) / tileSize);
        let testY = Math.floor((player.y + eyeY * distance) / tileSize);

        if (testX < 0 || testX >= mapWidth || testY < 0 || testY >= mapHeight) {
          hit = true;
          distance = maxDepth;
        } else if (map[testY][testX] === 1) {
          hit = true;
          wallX = player.x + eyeX * distance;
          wallY = player.y + eyeY * distance;
        }
      }

      // Correct fish-eye distortion
      distance = distance * Math.cos(player.angle - rayAngle);

      // Calculate wall height on screen
      const wallHeight = (tileSize * height) / distance;

      // Shade walls based on distance
      const shade = clamp(255 - distance * 0.7, 50, 255);
      ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;

      // Draw vertical strip
      ctx.fillRect(i * stripWidth, (height - wallHeight)/2, stripWidth + 1, wallHeight);
    }
  }

  // Normalize angle between 0 and 2PI
  function normalizeAngle(angle) {
    angle = angle % (2 * Math.PI);
    if (angle < 0) angle += 2 * Math.PI;
    return angle;
  }

  // Shooting mechanic - raycast center ray for hit detection
  function shoot() {
    if (player.ammo <= 0) return;

    player.ammo--;
    hud.textContent = `Ammo: ${player.ammo}`;

    const shootAngle = player.angle;

    // Cast a ray forward to max distance to detect hits on targets
    const maxShootDistance = 1000;
    for (let dist = 0; dist < maxShootDistance; dist += 5) {
      let testX = player.x + Math.cos(shootAngle) * dist;
      let testY = player.y + Math.sin(shootAngle) * dist;

      // Check wall hit, if hit stop
      if (isWall(testX, testY)) break;

      // Check targets
      for (let t of targets) {
        if (t.alive && distBetweenPoints(testX, testY, t.x, t.y) < t.radius) {
          t.alive = false;
          showHitEffect(t.x, t.y);
          return;
        }
      }
    }
  }

  // Distance between two points
  function distBetweenPoints(x1, y1, x2, y2) {
    return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
  }

  // Visual hit effect (simple white circle)
  let hitEffects = [];
  function showHitEffect(x, y) {
    hitEffects.push({x, y, alpha: 1.0});
  }

  // Draw targets
  function drawTargets() {
    for (let t of targets) {
      if (!t.alive) continue;
      // Compute relative position to player
      const dx = t.x - player.x;
      const dy = t.y - player.y;
      const distToTarget = Math.sqrt(dx*dx + dy*dy);

      // Angle between player direction and target
      let angleToTarget = Math.atan2(dy, dx) - player.angle;
      angleToTarget = ((angleToTarget + Math.PI) % (2 * Math.PI)) - Math.PI;

      // Only draw if inside field of view (FOV)
      if (Math.abs(angleToTarget) < fov / 2) {
        const screenX = (0.5 + angleToTarget / fov) * width;
        const size = (tileSize * height) / distToTarget;

        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(screenX, height/2, size / 4, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
  }

  // Draw hit effects (white circles fading)
  function drawHitEffects(dt) {
    for (let i = hitEffects.length - 1; i >= 0; i--) {
      let h = hitEffects[i];
      h.alpha -= dt * 2;
      if (h.alpha <= 0) {
        hitEffects.splice(i, 1);
        continue;
      }
      // Draw a white circle on the screen relative to player view
      const dx = h.x - player.x;
      const dy = h.y - player.y;
      const distToTarget = Math.sqrt(dx*dx + dy*dy);

      let angleToTarget = Math.atan2(dy, dx) - player.angle;
      angleToTarget = ((angleToTarget + Math.PI) % (2 * Math.PI)) - Math.PI;

      if (Math.abs(angleToTarget) < fov / 2) {
        const screenX = (0.5 + angleToTarget / fov) * width;
        const size = (tileSize * height) / distToTarget;
        ctx.fillStyle = `rgba(255,255,255,${h.alpha})`;
        ctx.beginPath();
        ctx.arc(screenX, height/2, size / 3, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
  }

  // Game loop
  function loop(timestamp = 0) {
    if (!lastTime) lastTime = timestamp;
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    updatePlayer(dt);
    castRays();
    drawTargets();
    drawHitEffects(dt);

    requestAnimationFrame(loop);
  }

  // Resize handler
  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  });

  // Initial draw
  loop();
})();
</script>

</body>
</html>
